# Secure Caddyfile for Telegram Bot Infrastructure

# Global options for security and performance
{
	# Automatic HTTPS
	auto_https on
	
	# Security settings
	servers {
		protocols h1 h2 h3
	}
	
	# Admin API (disable for production)
	admin off
	
	# Email for Let's Encrypt (set via environment or replace)
	email {$ACME_EMAIL:admin@yourdomain.com}
}

# Health check endpoint (accessible without domain)
:80 {
	# Health check for load balancer/monitoring
	handle /health {
		respond "OK" 200
	}
	
	# Global health endpoint for all services
	handle /health/caddy {
		respond "Caddy OK" 200
	}
	
	# Bot health check
	handle /health/bot {
		reverse_proxy {$BOT_SERVICE_NAME:order-bot-secure}:{$HEALTH_PORT:8080}
	}
	
	# Default redirect to HTTPS (if domain is configured)
	handle {
		@hasHost header Host *
		redir @hasHost https://{host}{uri} permanent
		
		# Fallback for direct IP access
		respond "Service Running - Use HTTPS with proper domain" 200
	}
	
	# Security headers
	header {
		X-Content-Type-Options nosniff
		X-Frame-Options DENY
		X-XSS-Protection "1; mode=block"
		Referrer-Policy strict-origin-when-cross-origin
		-Server
	}
	
	# Logging
	log {
		output file /var/log/caddy/access.log {
			roll_size 10MB
			roll_keep 5
		}
		format json
	}
}

# Production domain configuration (if DOMAIN is set)
{$DOMAIN:localhost} {
	# Root redirect
	handle / {
		respond "Telegram Bot Service - Health: /health" 200
	}
	
	# Health endpoints for monitoring
	handle /health {
		respond "System OK" 200
	}
	
	handle /health/caddy {
		respond "Caddy OK" 200
	}
	
	handle /health/bot {
		reverse_proxy {$BOT_SERVICE_NAME:order-bot-secure}:{$HEALTH_PORT:8080} {
			health_path /health
			health_interval 30s
			health_timeout 10s
		}
	}
	
	# Bot metrics endpoint (if implemented)
	handle /metrics {
		reverse_proxy {$BOT_SERVICE_NAME:order-bot-secure}:{$HEALTH_PORT:8080}
	}
	
	# Webhook endpoint for Telegram (if switching from polling)
	handle /webhook/* {
		reverse_proxy {$BOT_SERVICE_NAME:order-bot-secure}:{$HEALTH_PORT:8080}
	}
	
	# API endpoints (if bot exposes any)
	handle /api/* {
		reverse_proxy {$BOT_SERVICE_NAME:order-bot-secure}:{$HEALTH_PORT:8080} {
			header_up X-Real-IP {remote_host}
			header_up X-Forwarded-For {remote_host}
			header_up X-Forwarded-Proto {scheme}
		}
	}
	
	# Security headers
	header {
		X-Content-Type-Options nosniff
		X-Frame-Options DENY
		X-XSS-Protection "1; mode=block"
		Referrer-Policy strict-origin-when-cross-origin
		Strict-Transport-Security "max-age=31536000; includeSubDomains; preload"
		Content-Security-Policy "default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; connect-src 'self'"
		-Server
		-X-Powered-By
	}
	
	# Rate limiting
	rate_limit {
		zone dynamic {
			key {remote_host}
			events 100
			window 1m
		}
	}
	
	# Compression
	encode {
		gzip 6
		zstd
		match {
			header Content-Type application/json*
			header Content-Type application/javascript*
			header Content-Type text/*
		}
	}
	
	# Logging with structured format
	log {
		output file /var/log/caddy/access.log {
			roll_size 10MB
			roll_keep 10
		}
		format json {
			time_format "2006-01-02T15:04:05.000Z07:00"
			message_key "msg"
			level_key "level"
			time_key "ts"
		}
		level INFO
	}
	
	# Error handling
	handle_errors {
		@4xx expression {http.error.status_code} >= 400 && {http.error.status_code} < 500
		@5xx expression {http.error.status_code} >= 500
		
		handle @4xx {
			respond "Client Error" {http.error.status_code}
		}
		
		handle @5xx {
			respond "Server Error" {http.error.status_code}
		}
	}
}

# Development configuration (localhost)
localhost {
	handle / {
		respond "Telegram Bot Service - Development Mode" 200
	}
	
	handle /health {
		respond "Dev OK" 200
	}
	
	handle /health/bot {
		reverse_proxy order-bot-secure:8080
	}
	
	# More permissive CORS for development
	header {
		Access-Control-Allow-Origin *
		Access-Control-Allow-Methods "GET, POST, OPTIONS"
		Access-Control-Allow-Headers "Content-Type, Authorization"
	}
	
	log {
		output stdout
		level DEBUG
	}
}