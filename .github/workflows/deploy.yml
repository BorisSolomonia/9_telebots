name: üöÄ Deploy Telegram Bots

on:
  push:
    branches: [ master ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging

env:
  PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  REGION: europe-west3
  VM_HOST: ${{ secrets.VM_HOST }}
  DEPLOY_PATH: /opt/apps/telegram-bots
  VM_NAME: vm-runtime
  ZONE: europe-west3-b

jobs:
  build-and-deploy:
    name: üèóÔ∏è Build & Deploy Telegram Bots
    runs-on: ubuntu-latest

    steps:
      - name: üì• Checkout Code
        uses: actions/checkout@v4

      - name: ‚úÖ Validate Required Secrets
        run: |
          set -e
          [ -n "${{ secrets.GCP_PROJECT_ID }}" ] || { echo "‚ùå GCP_PROJECT_ID missing"; exit 1; }
          [ -n "${{ secrets.GCP_SA_KEY }}" ] || { echo "‚ùå GCP_SA_KEY missing"; exit 1; }
          [ -n "${{ secrets.VM_HOST }}" ] || { echo "‚ùå VM_HOST missing"; exit 1; }
          echo "‚úÖ Secrets OK"
          echo "PROJECT_ID=${{ env.PROJECT_ID }}"
          echo "REGION=${{ env.REGION }}"
          echo "VM_HOST=${{ env.VM_HOST }}"

      - name: üîê Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: ‚òÅÔ∏è Set up Google Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: üïµÔ∏è Who am I? / Config
        run: |
          gcloud --version
          gcloud auth list
          gcloud config list

      - name: üß© Set active project (defensive)
        run: |
          gcloud config set project "${PROJECT_ID}"
          echo "Active project: $(gcloud config get-value project)"

      - name: üê≥ Configure Docker for Artifact Registry
        run: gcloud auth configure-docker ${{ env.REGION }}-docker.pkg.dev --quiet

      - name: üèóÔ∏è Build & Push Bot Images
        env:
          IMAGE: ${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/apps/telegram-bots
        run: |
          docker build \
            --tag "${IMAGE}:${{ github.sha }}" \
            --tag "${IMAGE}:latest" .
          docker push "${IMAGE}:${{ github.sha }}"
          docker push "${IMAGE}:latest"

      - name: üì§ Create Deployment Script
        run: |
          echo "üìù Creating deployment script..."
          cat > deploy-script.sh << 'EOF'
          #!/bin/bash
          set -e
          echo "üöÄ Starting Telegram Bots deployment..."

          # Setup deployment directory
          sudo mkdir -p ${{ env.DEPLOY_PATH }}
          sudo chown -R $(whoami):$(whoami) ${{ env.DEPLOY_PATH }}
          cd ${{ env.DEPLOY_PATH }}

          # Create docker-compose.yml
          cat > docker-compose.yml << 'COMPOSE_EOF'
          version: "3.9"

          services:
            # Payment Bot
            payment-bot:
              image: ${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/apps/telegram-bots:latest
              container_name: payment-bot
              restart: unless-stopped
              command: ["python", "bot.py"]
              env_file: [.env]
              expose: ["8000"]
              networks: [web]
              mem_limit: 512m
              cpus: "0.3"
              volumes:
                - ./logs:/app/logs
              healthcheck:
                test: ["CMD", "python", "-c", "import sys; sys.exit(0)"]
                interval: 30s
                timeout: 10s
                retries: 3
                start_period: 30s
              depends_on:
                - caddy

            # Order Bot
            order-bot:
              image: ${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/apps/telegram-bots:latest
              container_name: order-bot
              restart: unless-stopped
              command: ["python", "order_bot.py"]
              env_file: [.env]
              expose: ["8001"]
              networks: [web]
              mem_limit: 512m
              cpus: "0.3"
              volumes:
                - ./logs:/app/logs
              healthcheck:
                test: ["CMD", "python", "-c", "import sys; sys.exit(0)"]
                interval: 30s
                timeout: 10s
                retries: 3
                start_period: 30s
              depends_on:
                - caddy

            # Caddy Reverse Proxy
            caddy:
              image: caddy:2-alpine
              container_name: caddy
              restart: unless-stopped
              ports:
                - "80:80"
                - "443:443"
              volumes:
                - ./Caddyfile:/etc/caddy/Caddyfile:ro
                - caddy_data:/data
                - caddy_config:/config
                - caddy_logs:/var/log/caddy
              networks: [web]
              mem_limit: 128m
              cpus: "0.25"
              healthcheck:
                test: ["CMD", "caddy", "version"]
                interval: 30s
                timeout: 10s
                retries: 3

          volumes:
            caddy_data:
              external: true
            caddy_config:
            caddy_logs:

          networks:
            web:
              external: true
          COMPOSE_EOF

          # Create Caddyfile
          cat > Caddyfile << 'CADDY_EOF'
          :80 {
            log {
              output stdout
              format console
            }

            # Health check endpoint
            @health { path /health }
            respond @health "OK" 200

            # Bot status endpoints
            handle /bots/payment/status {
              reverse_proxy payment-bot:8000
            }

            handle /bots/order/status {
              reverse_proxy order-bot:8001
            }

            # Default response for root
            handle /* {
              respond "9-Tones Telegram Bots - Status: Running" 200
            }

            # Enable compression
            encode gzip zstd

            # Basic security headers
            header {
              # Remove server info
              -Server
              # Security headers
              X-Content-Type-Options nosniff
              X-Frame-Options DENY
              X-XSS-Protection "1; mode=block"
              Referrer-Policy strict-origin-when-cross-origin
            }

            # Rate limiting
            @ratelimit {
              not remote_ip 127.0.0.1 ::1
            }
            rate_limit @ratelimit {
              zone bot_requests {
                key {remote_ip}
                events 60
                window 1m
              }
            }
          }
          CADDY_EOF

          # Fetch runtime secrets from Secret Manager
          echo "üîê Fetching secrets..."
          gcloud secrets versions access latest \
            --secret="telegram-bots-env" \
            --project=${{ env.PROJECT_ID }} > .env

          # Create logs directory
          mkdir -p logs

          # Pull latest images
          echo "üì• Pulling Docker images..."
          gcloud auth configure-docker ${{ env.REGION }}-docker.pkg.dev --quiet
          docker compose pull

          # Deploy the stack
          echo "üöÄ Deploying containers..."
          docker compose down --remove-orphans || true
          docker compose up -d --wait

          echo "‚úÖ Telegram bots deployment completed!"
          EOF

          chmod +x deploy-script.sh

      - name: üß™ Preflight: verify VM exists & we have rights
        run: |
          echo "üîé Checking VM '${VM_NAME}' in zone '${ZONE}' and project '${PROJECT_ID}'..."
          if ! gcloud compute instances describe "${VM_NAME}" --zone="${ZONE}" --project="${PROJECT_ID}" >/dev/null 2>&1; then
            echo "‚ùå Unable to describe VM."
            echo "   Check PROJECT_ID/ZONE/VM_NAME and IAM (roles/compute.instanceAdmin.v1 on CI identity)."
            exit 1
          fi
          echo "‚úÖ VM describe OK"

      - name: üöÄ Deploy via VM Startup Script
        run: |
          echo "üöÄ Setting startup script via metadata..."
          gcloud compute instances add-metadata "${VM_NAME}" \
            --zone="${ZONE}" \
            --project="${PROJECT_ID}" \
            --metadata-from-file startup-script=deploy-script.sh

          echo "üîÑ Restarting VM to trigger deployment..."
          gcloud compute instances stop "${VM_NAME}" --zone="${ZONE}" --project="${PROJECT_ID}" --quiet
          gcloud compute instances start "${VM_NAME}" --zone="${ZONE}" --project="${PROJECT_ID}" --quiet

          echo "‚è≥ Waiting 120s for startup script to finish..."
          sleep 120

      - name: üîç Health Check
        run: |
          echo "üîç Running health checks..."
          VM_IP=$(gcloud compute instances describe "${VM_NAME}" \
            --zone="${ZONE}" --project="${PROJECT_ID}" \
            --format='get(networkInterfaces[0].accessConfigs[0].natIP)')
          echo "VM IP: $VM_IP"

          echo "‚è≥ Waiting for services..."
          sleep 60

          echo "üîç Testing /health..."
          for i in {1..10}; do
            if curl -f --connect-timeout 10 "http://$VM_IP/health" >/dev/null 2>&1; then
              echo "‚úÖ Health OK (attempt $i)"; break
            fi
            echo "‚ùå Not ready (attempt $i)"; sleep 30
            [ $i -eq 10 ] && { echo "‚ùå Health check failed"; curl -v "http://$VM_IP/health" || true; exit 1; }
          done

          echo "ü§ñ Testing bot endpoints (best-effort)"
          curl -f "http://$VM_IP/" && echo "‚úÖ / OK" || echo "‚ö†Ô∏è / failed"
          curl -f "http://$VM_IP/bots/payment/status" && echo "‚úÖ payment ok" || echo "‚ö†Ô∏è payment failed"
          curl -f "http://$VM_IP/bots/order/status" && echo "‚úÖ order ok" || echo "‚ö†Ô∏è order failed"

          echo "‚úÖ Deployment health check completed"







# name: üöÄ Deploy Telegram Bots

# on:
#   push:
#     branches: [ master ]
#   workflow_dispatch:
#     inputs:
#       environment:
#         description: 'Environment to deploy'
#         required: true
#         default: 'production'
#         type: choice
#         options:
#           - production
#           - staging

# env:
#   PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
#   REGION: europe-west3
#   VM_HOST: ${{ secrets.VM_HOST }}
#   DEPLOY_PATH: /opt/apps/telegram-bots

# jobs:
#   build-and-deploy:
#     name: üèóÔ∏è Build & Deploy Telegram Bots
#     runs-on: ubuntu-latest
    
#     steps:
#       - name: üì• Checkout Code
#         uses: actions/checkout@v4

#       - name: ‚úÖ Validate Required Secrets
#         run: |
#           if [ -z "${{ secrets.GCP_PROJECT_ID }}" ]; then
#             echo "‚ùå ERROR: GCP_PROJECT_ID secret is not set"
#             echo "Please add GCP_PROJECT_ID to your GitHub repository secrets"
#             exit 1
#           fi
#           if [ -z "${{ secrets.GCP_SA_KEY }}" ]; then
#             echo "‚ùå ERROR: GCP_SA_KEY secret is not set"
#             echo "Please add your service account key to GitHub repository secrets"
#             exit 1
#           fi
#           if [ -z "${{ secrets.VM_HOST }}" ]; then
#             echo "‚ùå ERROR: VM_HOST secret is not set"
#             echo "Please add your VM IP address to GitHub repository secrets"
#             exit 1
#           fi
#           echo "‚úÖ All required secrets are configured"
#           echo "PROJECT_ID: ${{ env.PROJECT_ID }}"
#           echo "VM_HOST: ${{ env.VM_HOST }}"
#           echo "REGION: ${{ env.REGION }}"

#       - name: üîê Authenticate to Google Cloud
#         uses: google-github-actions/auth@v2
#         with:
#           credentials_json: ${{ secrets.GCP_SA_KEY }}

#       - name: ‚òÅÔ∏è Set up Google Cloud SDK
#         uses: google-github-actions/setup-gcloud@v2

#       - name: üê≥ Configure Docker
#         run: gcloud auth configure-docker ${{ env.REGION }}-docker.pkg.dev --quiet

#       - name: üèóÔ∏è Build & Push Bot Images
#         env:
#           IMAGE: ${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/apps/telegram-bots
#         run: |
#           # Build unified bot image
#           docker build \
#             --tag "${IMAGE}:${{ github.sha }}" \
#             --tag "${IMAGE}:latest" .
          
#           docker push "${IMAGE}:${{ github.sha }}"
#           docker push "${IMAGE}:latest"

#       - name: üì§ Create Deployment Script
#         run: |
#           echo "üìù Creating deployment script..."
          
#           cat > deploy-script.sh << 'EOF'
#           #!/bin/bash
#           set -e
          
#           echo "üöÄ Starting Telegram Bots deployment..."
          
#           # Setup deployment directory
#           sudo mkdir -p ${{ env.DEPLOY_PATH }}
#           sudo chown -R $(whoami):$(whoami) ${{ env.DEPLOY_PATH }}
#           cd ${{ env.DEPLOY_PATH }}
          
#           # Download deployment files from artifact registry metadata (as a workaround)
#           # Create docker-compose.yml
#           cat > docker-compose.yml << 'COMPOSE_EOF'
#           version: "3.9"
          
#           services:
#             # Payment Bot
#             payment-bot:
#               image: ${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/apps/telegram-bots:latest
#               container_name: payment-bot
#               restart: unless-stopped
#               command: ["python", "bot.py"]
#               env_file: [.env]
#               expose: ["8000"]
#               networks: [web]
#               mem_limit: 512m
#               cpus: "0.3"
#               volumes:
#                 - ./logs:/app/logs
#               healthcheck:
#                 test: ["CMD", "python", "-c", "import sys; sys.exit(0)"]
#                 interval: 30s
#                 timeout: 10s
#                 retries: 3
#                 start_period: 30s
#               depends_on:
#                 - caddy
          
#             # Order Bot
#             order-bot:
#               image: ${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/apps/telegram-bots:latest
#               container_name: order-bot
#               restart: unless-stopped
#               command: ["python", "order_bot.py"]
#               env_file: [.env]
#               expose: ["8001"]
#               networks: [web]
#               mem_limit: 512m
#               cpus: "0.3"
#               volumes:
#                 - ./logs:/app/logs
#               healthcheck:
#                 test: ["CMD", "python", "-c", "import sys; sys.exit(0)"]
#                 interval: 30s
#                 timeout: 10s
#                 retries: 3
#                 start_period: 30s
#               depends_on:
#                 - caddy
          
#             # Caddy Reverse Proxy
#             caddy:
#               image: caddy:2-alpine
#               container_name: caddy
#               restart: unless-stopped
#               ports:
#                 - "80:80"
#                 - "443:443"
#               volumes:
#                 - ./Caddyfile:/etc/caddy/Caddyfile:ro
#                 - caddy_data:/data
#                 - caddy_config:/config
#                 - caddy_logs:/var/log/caddy
#               networks: [web]
#               mem_limit: 128m
#               cpus: "0.25"
#               healthcheck:
#                 test: ["CMD", "caddy", "version"]
#                 interval: 30s
#                 timeout: 10s
#                 retries: 3
          
#           volumes:
#             caddy_data:
#               external: true
#             caddy_config:
#             caddy_logs:
          
#           networks:
#             web:
#               external: true
#           COMPOSE_EOF
          
#           # Create Caddyfile
#           cat > Caddyfile << 'CADDY_EOF'
#           :80 {
#           	log {
#           		output stdout
#           		format console
#           	}
          
#           	# Health check endpoint
#           	@health { path /health }
#           	respond @health "OK" 200
          
#           	# Bot status endpoints
#           	handle /bots/payment/status {
#           		reverse_proxy payment-bot:8000
#           	}
          
#           	handle /bots/order/status {
#           		reverse_proxy order-bot:8001
#           	}
          
#           	# Default response for root
#           	handle /* {
#           		respond "9-Tones Telegram Bots - Status: Running" 200
#           	}
          
#           	# Enable compression
#           	encode gzip zstd
          
#           	# Basic security headers
#           	header {
#           		# Remove server info
#           		-Server
#           		# Security headers
#           		X-Content-Type-Options nosniff
#           		X-Frame-Options DENY
#           		X-XSS-Protection "1; mode=block"
#           		Referrer-Policy strict-origin-when-cross-origin
#           	}
          
#           	# Rate limiting
#           	@ratelimit {
#           		not remote_ip 127.0.0.1 ::1
#           	}
#           	rate_limit @ratelimit {
#           		zone bot_requests {
#           			key {remote_ip}
#           			events 60
#           			window 1m
#           		}
#           	}
#           }
#           CADDY_EOF
          
#           # Fetch runtime secrets from Secret Manager
#           echo "üîê Fetching secrets..."
#           gcloud secrets versions access latest \
#             --secret="telegram-bots-env" \
#             --project=${{ env.PROJECT_ID }} > .env
          
#           # Create logs directory
#           mkdir -p logs
          
#           # Pull latest images
#           echo "üì• Pulling Docker images..."
#           gcloud auth configure-docker ${{ env.REGION }}-docker.pkg.dev --quiet
#           docker compose pull
          
#           # Deploy the stack
#           echo "üöÄ Deploying containers..."
#           docker compose down --remove-orphans || true
#           docker compose up -d --wait
          
#           echo "‚úÖ Telegram bots deployment completed!"
#           EOF
          
#           chmod +x deploy-script.sh

#       - name: üöÄ Deploy via VM Startup Script
#         run: |
#           echo "üöÄ Deploying to VM using startup script..."
          
#           # Upload and execute deployment script via startup script
#           gcloud compute instances add-metadata vm-runtime \
#             --zone=europe-west3-b \
#             --project=${{ env.PROJECT_ID }} \
#             --metadata-from-file startup-script=deploy-script.sh
          
#           # Restart the VM to trigger startup script
#           echo "üîÑ Restarting VM to trigger deployment..."
#           gcloud compute instances stop vm-runtime \
#             --zone=europe-west3-b \
#             --project=${{ env.PROJECT_ID }} \
#             --quiet
          
#           gcloud compute instances start vm-runtime \
#             --zone=europe-west3-b \
#             --project=${{ env.PROJECT_ID }} \
#             --quiet
          
#           echo "‚è≥ Waiting for VM to start and deployment to complete..."
#           sleep 120  # Wait for startup script to complete

#       - name: üîç Health Check
#         run: |
#           echo "üîç Running health checks..."
          
#           # Get VM external IP
#           VM_IP=$(gcloud compute instances describe vm-runtime \
#             --zone=europe-west3-b \
#             --project=${{ env.PROJECT_ID }} \
#             --format='get(networkInterfaces[0].accessConfigs[0].natIP)')
          
#           echo "VM IP: $VM_IP"
          
#           # Wait for services to be ready
#           echo "‚è≥ Waiting for services to start..."
#           sleep 60
          
#           # Test health endpoint
#           echo "üîç Testing health endpoint..."
#           for i in {1..10}; do
#             if curl -f --connect-timeout 10 "http://$VM_IP/health" >/dev/null 2>&1; then
#               echo "‚úÖ Health check passed on attempt $i"
#               break
#             else
#               echo "‚ùå Health check failed on attempt $i, retrying..."
#               if [ $i -eq 10 ]; then
#                 echo "‚ùå Health check failed after 10 attempts"
#                 curl -v "http://$VM_IP/health" || true
#                 exit 1
#               fi
#               sleep 30
#             fi
#           done
          
#           # Test specific endpoints
#           echo "ü§ñ Testing bot endpoints..."
#           curl -f "http://$VM_IP/" && echo "‚úÖ Main endpoint OK" || echo "‚ö†Ô∏è Main endpoint unavailable"
#           curl -f "http://$VM_IP/bots/payment/status" && echo "‚úÖ Payment bot OK" || echo "‚ö†Ô∏è Payment bot status unavailable"
#           curl -f "http://$VM_IP/bots/order/status" && echo "‚úÖ Order bot OK" || echo "‚ö†Ô∏è Order bot status unavailable"
          
#           echo "‚úÖ Deployment health check completed"