name: üöÄ Deploy (no hardcoded vars; secrets-only)

on:
  push:
    branches: [ main, master ]
  workflow_dispatch: {}

defaults:
  run:
    shell: bash

env:
  # All values come from Actions SECRETS only (no hardcoded constants)
  APP_NAME: ${{ secrets.APP_NAME }}
  GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  VM_HOST: ${{ secrets.VM_HOST }}
  VM_SSH_USER: ${{ secrets.VM_SSH_USER }}
  AR_REPO_NAME: ${{ secrets.AR_REPO_NAME }}
  AR_REGION: ${{ secrets.AR_REGION }}

jobs:
  build-and-push:
    name: üèóÔ∏è Build & Push
    runs-on: ubuntu-latest
    outputs:
      image_uri: ${{ steps.meta.outputs.image_uri }}
      ar_host:   ${{ steps.meta.outputs.ar_host }}
    steps:
      - name: üì• Checkout
        uses: actions/checkout@v4

      - name: üîê Auth GCP
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: ‚òÅÔ∏è Setup gcloud
        uses: google-github-actions/setup-gcloud@v2

      - name: üîé Print versions
        run: |
          set -x
          gcloud --version
          docker version

      - name: üîé Discover Artifact Registry (DOCKER)
        id: ar
        run: |
          set -x
          
          echo "=== Looking for ${AR_REPO_NAME} repository in ${AR_REGION} ==="
          
          # Check if AR_REPO_NAME exists in AR_REGION
          if gcloud artifacts repositories describe "${AR_REPO_NAME}" \
               --location="${AR_REGION}" \
               --project="${GCP_PROJECT_ID}" >/dev/null 2>&1; then
            echo "‚úÖ Found ${AR_REPO_NAME} in ${AR_REGION}"
            echo "repo=${AR_REPO_NAME}" >> "$GITHUB_OUTPUT"
            echo "region=${AR_REGION}" >> "$GITHUB_OUTPUT"
          else
            echo "‚ùå ${AR_REPO_NAME} not found in ${AR_REGION}"
            echo "=== Fallback: Getting all repository details ==="
            
            # Simple approach: use JSON format for reliable parsing
            repos_json="$(gcloud artifacts repositories list --project "${GCP_PROJECT_ID}" \
                         --filter='format=DOCKER' \
                         --format='json' || true)"
          
          echo "Repos JSON output:"
          echo "$repos_json"
          
          # Extract first repository with valid name and location
          REPO=""
          REGION=""
          
          if [[ -n "$repos_json" && "$repos_json" != "[]" ]]; then
            # Use jq if available, otherwise fallback to basic parsing
            if command -v jq >/dev/null 2>&1; then
              echo "Using jq for JSON parsing"
              # Extract name and location from the full path in the JSON
              full_name="$(echo "$repos_json" | jq -r '.[0].name // empty')"
              echo "Full name from JSON: '$full_name'"
              
              if [[ -n "$full_name" && "$full_name" != "null" ]]; then
                # Parse: projects/PROJECT/locations/REGION/repositories/REPO
                REPO="$(echo "$full_name" | sed 's|.*/repositories/||')"
                REGION="$(echo "$full_name" | sed 's|.*/locations/||' | sed 's|/repositories/.*||')"
              fi
            else
              echo "Using basic JSON parsing (no jq)"
              # Basic parsing without jq - extract name field
              full_name="$(echo "$repos_json" | grep -o '"name": *"[^"]*"' | head -1 | sed 's/.*"name": *"\([^"]*\)".*/\1/')"
              echo "Full name from basic parsing: '$full_name'"
              
              if [[ -n "$full_name" ]]; then
                # Parse: projects/PROJECT/locations/REGION/repositories/REPO
                REPO="$(echo "$full_name" | sed 's|.*/repositories/||')"
                REGION="$(echo "$full_name" | sed 's|.*/locations/||' | sed 's|/repositories/.*||')"
              fi
            fi
          fi
          
          echo "Parsed: REPO='$REPO', REGION='$REGION'"
          
          # Fallback: try simple list format if JSON parsing failed
          if [[ -z "$REGION" || -z "$REPO" ]]; then
            echo "=== Fallback: trying simple list format ==="
            
            list_output="$(gcloud artifacts repositories list --project "${GCP_PROJECT_ID}" \
                          --filter='format=DOCKER' \
                          --format='value(name,location)' || true)"
            echo "List output: '$list_output'"
            
            if [[ -n "$list_output" ]]; then
              # Process each line - gcloud value format uses spaces, not tabs
              while read -r line; do
                if [[ -z "$line" ]]; then continue; fi
                
                echo "Processing line: '$line'"
                # Extract name and location from space-separated line
                repo_full="$(echo "$line" | awk '{print $1}')"
                repo_location="$(echo "$line" | awk '{print $2}')"
                
                if [[ -n "$repo_full" && -n "$repo_location" ]]; then
                  # Extract just the repo name from full path
                  REPO="$(basename "$repo_full")"
                  REGION="$repo_location"
                  echo "‚úÖ Found: $REPO in $REGION"
                  break
                fi
              done <<< "$list_output"
            fi
          fi
          
            if [[ -z "$REGION" || -z "$REPO" ]]; then
              echo "‚ùå No DOCKER Artifact Registry found."
              echo "=== Debug: Listing all repositories ==="
              gcloud artifacts repositories list --project "${GCP_PROJECT_ID}" || true
              exit 1
            fi
            
            echo "‚úÖ Final selection: $REPO in $REGION"
            echo "repo=$REPO" >> "$GITHUB_OUTPUT"
            echo "region=$REGION" >> "$GITHUB_OUTPUT"
          fi

      - name: üê≥ Configure docker for AR
        run: |
          set -x
          AR_HOST="${{ steps.ar.outputs.region }}-docker.pkg.dev"
          echo "Configuring Docker for: $AR_HOST"
          gcloud auth configure-docker "$AR_HOST" --quiet

      - name: üìÅ Get customers.json from Secret Manager
        run: |
          set -x
          echo "Retrieving customers.json from Secret Manager"
          gcloud secrets versions access latest \
            --project "${GCP_PROJECT_ID}" \
            --secret "customers-json" > customers.json
          
          echo "customers.json retrieved successfully"
          ls -la customers.json || echo "Warning: customers.json not found"

      - name: üîê Get credentials.json from Secret Manager
        run: |
          set -x
          echo "Retrieving credentials.json from Secret Manager"
          gcloud secrets versions access latest \
            --project "${GCP_PROJECT_ID}" \
            --secret "credentials-for-sheets" > credentials.json
          
          echo "credentials.json retrieved successfully"
          ls -la credentials.json || echo "Warning: credentials.json not found"

      - name: üèóÔ∏è Build & Push image
        id: meta
        run: |
          set -x
          
          echo "üîç Debug build variables:"
          echo "GCP_PROJECT_ID: ${GCP_PROJECT_ID}"
          echo "APP_NAME: ${APP_NAME}"
          echo "GITHUB_SHA: ${GITHUB_SHA}"
          echo "AR region: ${{ steps.ar.outputs.region }}"
          echo "AR repo: ${{ steps.ar.outputs.repo }}"
          
          # Validate required variables
          if [[ -z "${GCP_PROJECT_ID}" ]]; then
            echo "‚ùå ERROR: GCP_PROJECT_ID is empty"
            exit 1
          fi
          if [[ -z "${APP_NAME}" ]]; then
            echo "‚ùå ERROR: APP_NAME is empty"
            exit 1
          fi
          if [[ -z "${{ steps.ar.outputs.region }}" ]]; then
            echo "‚ùå ERROR: AR region is empty"
            exit 1
          fi
          if [[ -z "${{ steps.ar.outputs.repo }}" ]]; then
            echo "‚ùå ERROR: AR repo is empty"
            exit 1
          fi
          
          AR_HOST="${{ steps.ar.outputs.region }}-docker.pkg.dev"
          IMAGE_BASE="${AR_HOST}/${GCP_PROJECT_ID}/${{ steps.ar.outputs.repo }}/${APP_NAME}"
          IMAGE_URI="${IMAGE_BASE}:${GITHUB_SHA}"

          echo "üîç Computed values:"
          echo "AR_HOST: ${AR_HOST}"
          echo "IMAGE_BASE: ${IMAGE_BASE}"
          echo "IMAGE_URI: ${IMAGE_URI}"
          
          echo "üîç This will create image with:"
          echo "Name: ${APP_NAME}"
          echo "Tag: ${GITHUB_SHA}"
          echo "Short tag: ${GITHUB_SHA:0:7}"
          echo "Expected full path: ${AR_HOST}/${GCP_PROJECT_ID}/${AR_REPO_NAME}/${APP_NAME}:${GITHUB_SHA}"
          
          # Validate AR path construction
          EXPECTED_AR_BASE="us-central1-docker.pkg.dev/nine-tones-bots-2025-468320/tasty-ar"
          ACTUAL_AR_BASE="${AR_HOST}/${GCP_PROJECT_ID}/${AR_REPO_NAME}"
          echo "üîç AR Path validation:"
          echo "Expected: ${EXPECTED_AR_BASE}"
          echo "Actual:   ${ACTUAL_AR_BASE}"
          
          if [[ "${ACTUAL_AR_BASE}" != "${EXPECTED_AR_BASE}" ]]; then
            echo "‚ùå ERROR: AR path mismatch!"
            echo "Check your GitHub Secrets:"
            echo "- GCP_PROJECT_ID should be: nine-tones-bots-2025-468320"
            echo "- AR_REGION should be: us-central1" 
            echo "- AR_REPO_NAME should be: tasty-ar"
            exit 1
          fi
          echo "‚úÖ AR path matches expected format"

          echo "Building ${IMAGE_URI}"
          docker build \
            -f secure-docker-setup/Dockerfile.secure \
            -t "${IMAGE_URI}" \
            -t "${IMAGE_BASE}:latest" \
            --label "org.opencontainers.image.source=${{ github.repository }}" \
            --label "org.opencontainers.image.revision=${GITHUB_SHA}" \
            --label "org.opencontainers.image.created=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" \
            .

          echo "üîç Pre-push variable check:"
          echo "IMAGE_URI before push: '${IMAGE_URI}'"
          echo "IMAGE_BASE before push: '${IMAGE_BASE}'"
          echo "AR_HOST before push: '${AR_HOST}'"
          
          echo "üöÄ Starting docker push..."
          docker push "${IMAGE_URI}"
          echo "‚úÖ Pushed ${IMAGE_URI}"
          
          docker push "${IMAGE_BASE}:latest"
          echo "‚úÖ Pushed ${IMAGE_BASE}:latest"
          
          echo "üîç Post-push variable check:"
          echo "IMAGE_URI after push: '${IMAGE_URI}'"
          echo "AR_HOST after push: '${AR_HOST}'"
          
          # Verify outputs are not empty BEFORE setting them
          if [[ -z "${IMAGE_URI}" ]]; then
            echo "‚ùå CRITICAL: IMAGE_URI is empty before setting output!"
            echo "This means variable was lost during execution."
            exit 1
          fi
          if [[ -z "${AR_HOST}" ]]; then
            echo "‚ùå CRITICAL: AR_HOST is empty before setting output!"
            echo "This means variable was lost during execution."
            exit 1
          fi
          
          echo "üîç About to set job outputs..."
          echo "GITHUB_OUTPUT file: ${GITHUB_OUTPUT}"
          echo "Current working directory: $(pwd)"
          
          echo "Setting image_uri=${IMAGE_URI}"
          echo "image_uri=${IMAGE_URI}" >> "$GITHUB_OUTPUT"
          echo "‚úÖ Wrote image_uri to output"
          
          echo "Setting ar_host=${AR_HOST}"
          echo "ar_host=${AR_HOST}" >> "$GITHUB_OUTPUT"
          echo "‚úÖ Wrote ar_host to output"
          
          echo "üîç Verifying GITHUB_OUTPUT file contents:"
          if [[ -f "$GITHUB_OUTPUT" ]]; then
            echo "GITHUB_OUTPUT exists, contents:"
            cat "$GITHUB_OUTPUT" | tail -10
          else
            echo "‚ùå GITHUB_OUTPUT file doesn't exist!"
          fi
          
          echo "‚úÖ Build and output setting completed successfully"

          echo "::group::Local images"
          docker images --digests | head -n 50
          echo "::endgroup::"

      - name: üîç Final Step Output Verification
        run: |
          echo "üîç Verifying step outputs are available:"
          echo "steps.meta.outputs.image_uri: '${{ steps.meta.outputs.image_uri }}'"
          echo "steps.meta.outputs.ar_host: '${{ steps.meta.outputs.ar_host }}'"
          
          if [[ -z "${{ steps.meta.outputs.image_uri }}" ]]; then
            echo "‚ùå CRITICAL: Step output image_uri is empty!"
            echo "Job outputs will be empty!"
            exit 1
          fi
          
          if [[ -z "${{ steps.meta.outputs.ar_host }}" ]]; then
            echo "‚ùå CRITICAL: Step output ar_host is empty!"  
            echo "Job outputs will be empty!"
            exit 1
          fi
          
          echo "‚úÖ Step outputs are properly set and will be available to dependent jobs"

  deploy:
    name: üöÄ Deploy on VM
    runs-on: ubuntu-latest
    needs: build-and-push
    steps:
      - name: üîç Verify build job success
        run: |
          echo "üîç Build job verification:"
          echo "Build job status: ${{ needs.build-and-push.result }}"
          
          if [[ "${{ needs.build-and-push.result }}" != "success" ]]; then
            echo "‚ùå ERROR: Build job did not complete successfully!"
            echo "Status: ${{ needs.build-and-push.result }}"
            echo "Cannot proceed with deployment."
            exit 1
          fi
          
          echo "‚úÖ Build job completed successfully"
          echo "üîç Will construct IMAGE_URI directly from secrets to bypass GitHub's output filtering"
      - name: üì• Checkout
        uses: actions/checkout@v4

      - name: üîê Auth GCP (for Secret Manager + AR token)
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: ‚òÅÔ∏è Setup gcloud
        uses: google-github-actions/setup-gcloud@v2

      - name: üßæ Build .env from Secret Manager (<APP>-env)
        run: |
          set -x
          gcloud secrets versions access latest \
            --project "${GCP_PROJECT_ID}" \
            --secret "${APP_NAME}-env" > .env

          echo "::group::.env (first lines)"
          head -n 20 .env || true
          echo "::endgroup::"

      - name: üîë Get short-lived AR token
        id: token
        run: |
          set -x
          echo "token=$(gcloud auth print-access-token)" >> "$GITHUB_OUTPUT"

      - name: üìÅ Ensure target directory exists
        uses: appleboy/ssh-action@v1.0.3
        env:
          APP_NAME: ${{ env.APP_NAME }}
        with:
          host: ${{ env.VM_HOST }}
          username: ${{ env.VM_SSH_USER }}
          key: ${{ secrets.VM_SSH_KEY }}
          envs: APP_NAME
          script: |
            set -euo pipefail
            APP_DIR="/opt/$APP_NAME"
            echo "Creating directory: $APP_DIR"
            sudo mkdir -p "$APP_DIR"
            sudo chown "$USER:$USER" "$APP_DIR"
            ls -la "$APP_DIR" || true

      - name: üì§ Copy repo files + .env to VM
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ env.VM_HOST }}
          username: ${{ env.VM_SSH_USER }}
          key: ${{ secrets.VM_SSH_KEY }}
          overwrite: true
          strip_components: 0
          source: "secure-docker-setup/,.env"
          target: "/opt/${{ env.APP_NAME }}/"
          debug: true

      - name: üê≥ Deploy (compose up -d)
        uses: appleboy/ssh-action@v1.0.3
        env:
          AR_TOKEN:  ${{ steps.token.outputs.token }}
          APP_NAME:  ${{ env.APP_NAME }}
          AR_REPO_NAME: ${{ env.AR_REPO_NAME }}
          AR_REGION: ${{ env.AR_REGION }}
          GCP_PROJECT_ID: ${{ env.GCP_PROJECT_ID }}
          GITHUB_SHA: ${{ github.sha }}
        with:
          host:     ${{ env.VM_HOST }}
          username: ${{ env.VM_SSH_USER }}
          key:      ${{ secrets.VM_SSH_KEY }}
          envs:     AR_TOKEN,APP_NAME,AR_REPO_NAME,AR_REGION,GCP_PROJECT_ID,GITHUB_SHA
          script: |
            set -euo pipefail
            
            # Check available docker compose commands
            echo "üîç Checking docker compose availability:"
            if command -v docker &> /dev/null; then
              echo "‚úÖ docker available"
              docker --version
            fi
            if docker compose version &> /dev/null; then
              echo "‚úÖ docker compose available"
              docker compose version
              dco() { docker compose "$@"; }
            elif command -v docker-compose &> /dev/null; then
              echo "‚úÖ docker-compose available"  
              docker-compose --version
              dco() { docker-compose "$@"; }
            else
              echo "‚ùå Neither docker compose nor docker-compose found!"
              exit 1
            fi

            echo "üîç Debug environment variables:"
            echo "APP_NAME: $APP_NAME"
            echo "AR_REPO_NAME: $AR_REPO_NAME"
            echo "AR_REGION: $AR_REGION"  
            echo "GCP_PROJECT_ID: $GCP_PROJECT_ID"
            echo "GITHUB_SHA: $GITHUB_SHA"
            
            # Construct AR_HOST and IMAGE_URI directly (bypass GitHub's secret filtering)
            AR_HOST="${AR_REGION}-docker.pkg.dev"
            IMAGE_URI="${AR_HOST}/${GCP_PROJECT_ID}/${AR_REPO_NAME}/${APP_NAME}:${GITHUB_SHA}"
            
            echo "üîç Constructed values:"
            echo "AR_HOST: $AR_HOST"
            echo "IMAGE_URI: $IMAGE_URI"
            
            # Validate construction
            if [[ -z "$AR_HOST" ]] || [[ -z "$IMAGE_URI" ]]; then
              echo "‚ùå ERROR: Failed to construct AR_HOST or IMAGE_URI!"
              echo "Check that all required environment variables are set."
              exit 1
            fi
            
            echo "‚úÖ Successfully constructed deployment values"

            APP_DIR="/opt/$APP_NAME"
            sudo mkdir -p "$APP_DIR"
            sudo chown "$USER:$USER" "$APP_DIR"
            cd "$APP_DIR"

            echo "üîê Docker login to ${AR_HOST} using CI token"
            echo "${AR_TOKEN}" | docker login -u oauth2accesstoken --password-stdin "${AR_HOST}"
            
            echo "‚úÖ AR Connection Details:"
            echo "AR Host: ${AR_HOST}"
            echo "AR Repository: ${AR_REPO_NAME}"
            echo "AR Region: ${AR_REGION}"
            echo "Image to deploy: ${IMAGE_URI}"

            echo "üîß Fix .env file location and add missing vars FIRST"
            echo "Debug: We're in directory: $(pwd)"
            echo "Debug: Checking file existence in current directory..."
            ls -la . | head -20 || true
            echo "Debug: Checking secure-docker-setup directory..."
            ls -la secure-docker-setup/ | head -10 || true
            
            # The .env file should be here from SCP action
            if [ -f ".env" ]; then
              echo "‚úÖ .env found in current directory"
              echo "First few lines of .env:"
              head -5 .env || true
              
              if [ ! -f "secure-docker-setup/.env" ]; then
                echo "Copying .env to secure-docker-setup/"
                cp .env secure-docker-setup/.env
                
                # Add REDIS_PASSWORD if not present
                if ! grep -q "REDIS_PASSWORD" secure-docker-setup/.env; then
                  echo "REDIS_PASSWORD=secure_redis_pass_$(openssl rand -hex 12)" >> secure-docker-setup/.env
                  echo "Added REDIS_PASSWORD to .env"
                fi
                echo "‚úÖ .env copied and configured"
                echo "Final .env file size:" $(wc -l secure-docker-setup/.env)
              else
                echo "‚úÖ secure-docker-setup/.env already exists"
              fi
              
              echo "üîë Create Google Sheets credentials file from environment"
              cd secure-docker-setup
              # Check if GOOGLE_CREDENTIALS or similar exists in .env
              if grep -q "GOOGLE_CREDENTIALS\|SHEETS_CREDS\|GCP_SA_KEY" .env; then
                echo "Found Google credentials in .env, creating credentials.json"
                
                # Extract credentials (try different possible variable names)
                CREDS_JSON=$(grep -E "^(GOOGLE_CREDENTIALS|SHEETS_CREDS|GCP_SA_KEY)=" .env | head -1 | cut -d= -f2- | tr -d '"'"''"'"')
                
                if [ -n "$CREDS_JSON" ]; then
                  echo "$CREDS_JSON" > credentials.json
                  chmod 600 credentials.json
                  echo "‚úÖ Created credentials.json from environment variable"
                  
                  # Validate it's valid JSON
                  if python3 -m json.tool credentials.json > /dev/null 2>&1; then
                    echo "‚úÖ credentials.json is valid JSON"
                  else
                    echo "‚ùå credentials.json is invalid JSON - check the environment variable format"
                    head -c 100 credentials.json
                  fi
                else
                  echo "‚ùå Found credentials variable but value is empty"
                fi
              else
                echo "‚ùå No Google credentials found in .env file"
                echo "Looking for variables containing 'CRED' or 'GOOGLE':"
                grep -i -E "(cred|google)" .env || echo "No credential variables found"
              fi
              cd ..
            else
              echo "‚ùå .env not found in current directory: $(pwd)"
              echo "Available files (first 30):"
              ls -la . | head -30
              echo "Looking for any .env files recursively:"
              find . -name "*.env" -type f 2>/dev/null | head -10 || echo "No .env files found"
            fi

            echo "üìù Fix compose file and patch image"
            echo "Before compose file modifications:"
            ls -la secure-docker-setup/docker-compose.secure.yml || echo "Compose file not found"
            
            # Check file contents before modification
            echo "Compose file size before:" $(wc -l secure-docker-setup/docker-compose.secure.yml 2>/dev/null || echo "0")
            
            # Remove obsolete version field
            sed -i "/^version:/d" secure-docker-setup/docker-compose.secure.yml || true
            
            echo "Compose file size after version removal:" $(wc -l secure-docker-setup/docker-compose.secure.yml 2>/dev/null || echo "0")

            echo "üßπ Stop previous services (idempotent)"
            dco -f secure-docker-setup/docker-compose.secure.yml down --remove-orphans || true
            if [ -d "infra/caddy" ]; then
              echo "Stopping Caddy services (if configured)..."
              ( cd infra/caddy && if grep -q "^[[:space:]]*[^#].*:" compose.yml 2>/dev/null; then dco down || true; else echo "Caddy compose empty - nothing to stop"; fi )
            fi
            
            # Update image
            echo "üìù Patch compose to use ${IMAGE_URI}"
            echo "Running image replacements..."
            
            # Check if compose file still exists and has content
            if [ -f "secure-docker-setup/docker-compose.secure.yml" ] && [ -s "secure-docker-setup/docker-compose.secure.yml" ]; then
              echo "Compose file exists and has content"
              
              # Show what we're replacing
              echo "Looking for 'build:' lines to replace:"
              grep -n "build:" secure-docker-setup/docker-compose.secure.yml || echo "No build: lines found"
              
              # Apply replacements - handle multi-line build block properly
              # First, replace the build: line with image:
              sed -i "s|^\s*build:\s*$|    image: ${IMAGE_URI}|g" secure-docker-setup/docker-compose.secure.yml || true
              # Then remove any context and dockerfile lines (they're now invalid)
              sed -i "/^\s*context:/d" secure-docker-setup/docker-compose.secure.yml || true  
              sed -i "/^\s*dockerfile:/d" secure-docker-setup/docker-compose.secure.yml || true
              
              echo "Final compose file size:" $(wc -l secure-docker-setup/docker-compose.secure.yml 2>/dev/null || echo "0")
              
              # Show final result
              echo "After replacements, checking for 'image:' lines:"
              grep -n "image:" secure-docker-setup/docker-compose.secure.yml || echo "No image: lines found"
              
              # Validate YAML syntax
              echo "Validating YAML syntax:"
              if docker compose -f secure-docker-setup/docker-compose.secure.yml config --quiet 2>/dev/null; then
                echo "‚úÖ YAML syntax is valid"
              else
                echo "‚ùå YAML syntax error detected!"
                echo "Showing problematic lines around the image section:"
                grep -n -A 5 -B 5 "image:" secure-docker-setup/docker-compose.secure.yml || true
                echo "Full file contents:"
                cat -n secure-docker-setup/docker-compose.secure.yml | head -20
              fi
              
            else
              echo "‚ùå Compose file is missing or empty after modifications!"
              ls -la secure-docker-setup/
              exit 1
            fi

            echo "üï∏Ô∏è Ensure networks (after compose file is ready)"
            # Create networks that match the compose file
            docker network create web 2>/dev/null || true
            docker network create bot_network --internal 2>/dev/null || true
            # Legacy networks for backward compatibility  
            docker network create bot_internal --internal 2>/dev/null || true

            echo "üîê Set perms"
            chmod 600 .env 2>/dev/null || true

            echo "‚ÑπÔ∏è  Using existing Caddy on VM - no separate Caddy deployment"

            echo "ü§ñ Deploy app"
            dco -f secure-docker-setup/docker-compose.secure.yml pull
            dco -f secure-docker-setup/docker-compose.secure.yml up -d

            echo "üîé Containers:"
            docker ps --format 'table {{.Names}}\t{{.Status}}\t{{.Ports}}'

  health:
    name: üè• Health & Logs
    runs-on: ubuntu-latest
    needs: [deploy]
    steps:
      - name: üîê Auth GCP (for curl timeout on runner only)
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: üåê External health check
        run: |
          set -x
          if timeout 12 curl -fsS "http://${{ env.VM_HOST }}/health" >/dev/null; then
            echo "‚úÖ External /health OK"
          else
            echo "‚ùå External /health failed"
          fi

      - name: üîé VM container status & logs
        uses: appleboy/ssh-action@v1.0.3
        env:
          APP_NAME: ${{ env.APP_NAME }}
        with:
          host:     ${{ env.VM_HOST }}
          username: ${{ env.VM_SSH_USER }}
          key:      ${{ secrets.VM_SSH_KEY }}
          envs:     APP_NAME
          script: |
            set -euo pipefail
            echo "üîç docker ps"
            docker ps --format 'table {{.Names}}\t{{.Status}}\t{{.Ports}}' || true

            echo
            echo "üìã Recent app logs (tail 200)"
            # Use the actual container name from the compose file
            docker logs order-bot-secure --tail 200 || docker logs ${APP_NAME} --tail 200 || true

            echo
            echo "üìã Recent caddy logs (tail 120)"
            docker logs caddy  --tail 120 || true
            docker logs caddy-proxy --tail 120 || true
