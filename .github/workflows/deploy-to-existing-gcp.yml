name: üöÄ Deploy (no hardcoded vars; secrets-only)

on:
  push:
    branches: [ main, master ]
  workflow_dispatch: {}

defaults:
  run:
    shell: bash

env:
  # All values come from Actions SECRETS only (no hardcoded constants)
  APP_NAME: ${{ secrets.APP_NAME }}
  GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  VM_HOST: ${{ secrets.VM_HOST }}
  VM_SSH_USER: ${{ secrets.VM_SSH_USER }}
  AR_REPO_NAME: ${{ secrets.AR_REPO_NAME }}
  AR_REGION: ${{ secrets.AR_REGION }}

jobs:
  build-and-push:
    name: üèóÔ∏è Build & Push
    runs-on: ubuntu-latest
    outputs:
      image_uri: ${{ steps.meta.outputs.image_uri }}
      ar_host:   ${{ steps.meta.outputs.ar_host }}
    steps:
      - name: üì• Checkout
        uses: actions/checkout@v4

      - name: üîê Auth GCP
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: ‚òÅÔ∏è Setup gcloud
        uses: google-github-actions/setup-gcloud@v2

      - name: üîé Print versions
        run: |
          set -x
          gcloud --version
          docker version

      - name: üîé Discover Artifact Registry (DOCKER)
        id: ar
        run: |
          set -x
          
          echo "=== Looking for ${AR_REPO_NAME} repository in ${AR_REGION} ==="
          
          # Check if AR_REPO_NAME exists in AR_REGION
          if gcloud artifacts repositories describe "${AR_REPO_NAME}" \
               --location="${AR_REGION}" \
               --project="${GCP_PROJECT_ID}" >/dev/null 2>&1; then
            echo "‚úÖ Found ${AR_REPO_NAME} in ${AR_REGION}"
            echo "repo=${AR_REPO_NAME}" >> "$GITHUB_OUTPUT"
            echo "region=${AR_REGION}" >> "$GITHUB_OUTPUT"
          else
            echo "‚ùå ${AR_REPO_NAME} not found in ${AR_REGION}"
            echo "=== Fallback: Getting all repository details ==="
            
            # Simple approach: use JSON format for reliable parsing
            repos_json="$(gcloud artifacts repositories list --project "${GCP_PROJECT_ID}" \
                         --filter='format=DOCKER' \
                         --format='json' || true)"
          
          echo "Repos JSON output:"
          echo "$repos_json"
          
          # Extract first repository with valid name and location
          REPO=""
          REGION=""
          
          if [[ -n "$repos_json" && "$repos_json" != "[]" ]]; then
            # Use jq if available, otherwise fallback to basic parsing
            if command -v jq >/dev/null 2>&1; then
              echo "Using jq for JSON parsing"
              # Extract name and location from the full path in the JSON
              full_name="$(echo "$repos_json" | jq -r '.[0].name // empty')"
              echo "Full name from JSON: '$full_name'"
              
              if [[ -n "$full_name" && "$full_name" != "null" ]]; then
                # Parse: projects/PROJECT/locations/REGION/repositories/REPO
                REPO="$(echo "$full_name" | sed 's|.*/repositories/||')"
                REGION="$(echo "$full_name" | sed 's|.*/locations/||' | sed 's|/repositories/.*||')"
              fi
            else
              echo "Using basic JSON parsing (no jq)"
              # Basic parsing without jq - extract name field
              full_name="$(echo "$repos_json" | grep -o '"name": *"[^"]*"' | head -1 | sed 's/.*"name": *"\([^"]*\)".*/\1/')"
              echo "Full name from basic parsing: '$full_name'"
              
              if [[ -n "$full_name" ]]; then
                # Parse: projects/PROJECT/locations/REGION/repositories/REPO
                REPO="$(echo "$full_name" | sed 's|.*/repositories/||')"
                REGION="$(echo "$full_name" | sed 's|.*/locations/||' | sed 's|/repositories/.*||')"
              fi
            fi
          fi
          
          echo "Parsed: REPO='$REPO', REGION='$REGION'"
          
          # Fallback: try simple list format if JSON parsing failed
          if [[ -z "$REGION" || -z "$REPO" ]]; then
            echo "=== Fallback: trying simple list format ==="
            
            list_output="$(gcloud artifacts repositories list --project "${GCP_PROJECT_ID}" \
                          --filter='format=DOCKER' \
                          --format='value(name,location)' || true)"
            echo "List output: '$list_output'"
            
            if [[ -n "$list_output" ]]; then
              # Process each line - gcloud value format uses spaces, not tabs
              while read -r line; do
                if [[ -z "$line" ]]; then continue; fi
                
                echo "Processing line: '$line'"
                # Extract name and location from space-separated line
                repo_full="$(echo "$line" | awk '{print $1}')"
                repo_location="$(echo "$line" | awk '{print $2}')"
                
                if [[ -n "$repo_full" && -n "$repo_location" ]]; then
                  # Extract just the repo name from full path
                  REPO="$(basename "$repo_full")"
                  REGION="$repo_location"
                  echo "‚úÖ Found: $REPO in $REGION"
                  break
                fi
              done <<< "$list_output"
            fi
          fi
          
            if [[ -z "$REGION" || -z "$REPO" ]]; then
              echo "‚ùå No DOCKER Artifact Registry found."
              echo "=== Debug: Listing all repositories ==="
              gcloud artifacts repositories list --project "${GCP_PROJECT_ID}" || true
              exit 1
            fi
            
            echo "‚úÖ Final selection: $REPO in $REGION"
            echo "repo=$REPO" >> "$GITHUB_OUTPUT"
            echo "region=$REGION" >> "$GITHUB_OUTPUT"
          fi

      - name: üê≥ Configure docker for AR
        run: |
          set -x
          AR_HOST="${{ steps.ar.outputs.region }}-docker.pkg.dev"
          echo "Configuring Docker for: $AR_HOST"
          gcloud auth configure-docker "$AR_HOST" --quiet

      - name: üìÅ Get customers.json from Secret Manager
        run: |
          set -x
          echo "Retrieving customers.json from Secret Manager"
          gcloud secrets versions access latest \
            --project "${GCP_PROJECT_ID}" \
            --secret "customers-json" > customers.json
          
          echo "customers.json retrieved successfully"
          ls -la customers.json || echo "Warning: customers.json not found"

      - name: üèóÔ∏è Build & Push image
        id: meta
        run: |
          set -x
          
          echo "üîç Debug build variables:"
          echo "GCP_PROJECT_ID: ${GCP_PROJECT_ID}"
          echo "APP_NAME: ${APP_NAME}"
          echo "GITHUB_SHA: ${GITHUB_SHA}"
          echo "AR region: ${{ steps.ar.outputs.region }}"
          echo "AR repo: ${{ steps.ar.outputs.repo }}"
          
          # Validate required variables
          if [[ -z "${GCP_PROJECT_ID}" ]]; then
            echo "‚ùå ERROR: GCP_PROJECT_ID is empty"
            exit 1
          fi
          if [[ -z "${APP_NAME}" ]]; then
            echo "‚ùå ERROR: APP_NAME is empty"
            exit 1
          fi
          if [[ -z "${{ steps.ar.outputs.region }}" ]]; then
            echo "‚ùå ERROR: AR region is empty"
            exit 1
          fi
          if [[ -z "${{ steps.ar.outputs.repo }}" ]]; then
            echo "‚ùå ERROR: AR repo is empty"
            exit 1
          fi
          
          AR_HOST="${{ steps.ar.outputs.region }}-docker.pkg.dev"
          IMAGE_BASE="${AR_HOST}/${GCP_PROJECT_ID}/${{ steps.ar.outputs.repo }}/${APP_NAME}"
          IMAGE_URI="${IMAGE_BASE}:${GITHUB_SHA}"

          echo "üîç Computed values:"
          echo "AR_HOST: ${AR_HOST}"
          echo "IMAGE_BASE: ${IMAGE_BASE}"
          echo "IMAGE_URI: ${IMAGE_URI}"
          
          echo "üîç This will create image with:"
          echo "Name: ${APP_NAME}"
          echo "Tag: ${GITHUB_SHA}"
          echo "Short tag: ${GITHUB_SHA:0:7}"
          echo "Expected full path: ${AR_HOST}/${GCP_PROJECT_ID}/${AR_REPO_NAME}/${APP_NAME}:${GITHUB_SHA}"
          
          # Validate AR path construction
          EXPECTED_AR_BASE="us-central1-docker.pkg.dev/nine-tones-bots-2025-468320/tasty-ar"
          ACTUAL_AR_BASE="${AR_HOST}/${GCP_PROJECT_ID}/${AR_REPO_NAME}"
          echo "üîç AR Path validation:"
          echo "Expected: ${EXPECTED_AR_BASE}"
          echo "Actual:   ${ACTUAL_AR_BASE}"
          
          if [[ "${ACTUAL_AR_BASE}" != "${EXPECTED_AR_BASE}" ]]; then
            echo "‚ùå ERROR: AR path mismatch!"
            echo "Check your GitHub Secrets:"
            echo "- GCP_PROJECT_ID should be: nine-tones-bots-2025-468320"
            echo "- AR_REGION should be: us-central1" 
            echo "- AR_REPO_NAME should be: tasty-ar"
            exit 1
          fi
          echo "‚úÖ AR path matches expected format"

          echo "Building ${IMAGE_URI}"
          docker build \
            -f secure-docker-setup/Dockerfile.secure \
            -t "${IMAGE_URI}" \
            -t "${IMAGE_BASE}:latest" \
            --label "org.opencontainers.image.source=${{ github.repository }}" \
            --label "org.opencontainers.image.revision=${GITHUB_SHA}" \
            --label "org.opencontainers.image.created=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" \
            .

          echo "üîç Pre-push variable check:"
          echo "IMAGE_URI before push: '${IMAGE_URI}'"
          echo "IMAGE_BASE before push: '${IMAGE_BASE}'"
          echo "AR_HOST before push: '${AR_HOST}'"
          
          echo "üöÄ Starting docker push..."
          docker push "${IMAGE_URI}"
          echo "‚úÖ Pushed ${IMAGE_URI}"
          
          docker push "${IMAGE_BASE}:latest"
          echo "‚úÖ Pushed ${IMAGE_BASE}:latest"
          
          echo "üîç Post-push variable check:"
          echo "IMAGE_URI after push: '${IMAGE_URI}'"
          echo "AR_HOST after push: '${AR_HOST}'"
          
          # Verify outputs are not empty BEFORE setting them
          if [[ -z "${IMAGE_URI}" ]]; then
            echo "‚ùå CRITICAL: IMAGE_URI is empty before setting output!"
            echo "This means variable was lost during execution."
            exit 1
          fi
          if [[ -z "${AR_HOST}" ]]; then
            echo "‚ùå CRITICAL: AR_HOST is empty before setting output!"
            echo "This means variable was lost during execution."
            exit 1
          fi
          
          echo "üîç About to set job outputs..."
          echo "GITHUB_OUTPUT file: ${GITHUB_OUTPUT}"
          echo "Current working directory: $(pwd)"
          
          echo "Setting image_uri=${IMAGE_URI}"
          echo "image_uri=${IMAGE_URI}" >> "$GITHUB_OUTPUT"
          echo "‚úÖ Wrote image_uri to output"
          
          echo "Setting ar_host=${AR_HOST}"
          echo "ar_host=${AR_HOST}" >> "$GITHUB_OUTPUT"
          echo "‚úÖ Wrote ar_host to output"
          
          echo "üîç Verifying GITHUB_OUTPUT file contents:"
          if [[ -f "$GITHUB_OUTPUT" ]]; then
            echo "GITHUB_OUTPUT exists, contents:"
            cat "$GITHUB_OUTPUT" | tail -10
          else
            echo "‚ùå GITHUB_OUTPUT file doesn't exist!"
          fi
          
          echo "‚úÖ Build and output setting completed successfully"

          echo "::group::Local images"
          docker images --digests | head -n 50
          echo "::endgroup::"

      - name: üîç Final Step Output Verification
        run: |
          echo "üîç Verifying step outputs are available:"
          echo "steps.meta.outputs.image_uri: '${{ steps.meta.outputs.image_uri }}'"
          echo "steps.meta.outputs.ar_host: '${{ steps.meta.outputs.ar_host }}'"
          
          if [[ -z "${{ steps.meta.outputs.image_uri }}" ]]; then
            echo "‚ùå CRITICAL: Step output image_uri is empty!"
            echo "Job outputs will be empty!"
            exit 1
          fi
          
          if [[ -z "${{ steps.meta.outputs.ar_host }}" ]]; then
            echo "‚ùå CRITICAL: Step output ar_host is empty!"  
            echo "Job outputs will be empty!"
            exit 1
          fi
          
          echo "‚úÖ Step outputs are properly set and will be available to dependent jobs"

  deploy:
    name: üöÄ Deploy on VM
    runs-on: ubuntu-latest
    needs: build-and-push
    steps:
      - name: üîç Verify build job success
        run: |
          echo "üîç Build job verification:"
          echo "Build job status: ${{ needs.build-and-push.result }}"
          
          if [[ "${{ needs.build-and-push.result }}" != "success" ]]; then
            echo "‚ùå ERROR: Build job did not complete successfully!"
            echo "Status: ${{ needs.build-and-push.result }}"
            echo "Cannot proceed with deployment."
            exit 1
          fi
          
          echo "‚úÖ Build job completed successfully"
          echo "üîç Will construct IMAGE_URI directly from secrets to bypass GitHub's output filtering"
      - name: üì• Checkout
        uses: actions/checkout@v4

      - name: üîê Auth GCP (for Secret Manager + AR token)
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: ‚òÅÔ∏è Setup gcloud
        uses: google-github-actions/setup-gcloud@v2

      - name: üßæ Build .env from Secret Manager (<APP>-env)
        run: |
          set -x
          gcloud secrets versions access latest \
            --project "${GCP_PROJECT_ID}" \
            --secret "${APP_NAME}-env" > .env

          echo "::group::.env (first lines)"
          head -n 20 .env || true
          echo "::endgroup::"

      - name: üîë Get short-lived AR token
        id: token
        run: |
          set -x
          echo "token=$(gcloud auth print-access-token)" >> "$GITHUB_OUTPUT"

      - name: üìÅ Ensure target directory exists
        uses: appleboy/ssh-action@v1.0.3
        env:
          APP_NAME: ${{ env.APP_NAME }}
        with:
          host: ${{ env.VM_HOST }}
          username: ${{ env.VM_SSH_USER }}
          key: ${{ secrets.VM_SSH_KEY }}
          envs: APP_NAME
          script: |
            set -euo pipefail
            APP_DIR="/opt/$APP_NAME"
            echo "Creating directory: $APP_DIR"
            sudo mkdir -p "$APP_DIR"
            sudo chown "$USER:$USER" "$APP_DIR"
            ls -la "$APP_DIR" || true

      - name: üì§ Copy repo files + .env to VM
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ env.VM_HOST }}
          username: ${{ env.VM_SSH_USER }}
          key: ${{ secrets.VM_SSH_KEY }}
          overwrite: true
          strip_components: 0
          source: "infra/,secure-docker-setup/,.env"
          target: "/opt/${{ env.APP_NAME }}/"
          debug: true

      - name: üê≥ Deploy (compose up -d)
        uses: appleboy/ssh-action@v1.0.3
        env:
          AR_TOKEN:  ${{ steps.token.outputs.token }}
          APP_NAME:  ${{ env.APP_NAME }}
          AR_REPO_NAME: ${{ env.AR_REPO_NAME }}
          AR_REGION: ${{ env.AR_REGION }}
          GCP_PROJECT_ID: ${{ env.GCP_PROJECT_ID }}
          GITHUB_SHA: ${{ github.sha }}
        with:
          host:     ${{ env.VM_HOST }}
          username: ${{ env.VM_SSH_USER }}
          key:      ${{ secrets.VM_SSH_KEY }}
          envs:     AR_TOKEN,APP_NAME,AR_REPO_NAME,AR_REGION,GCP_PROJECT_ID,GITHUB_SHA
          script: |
            set -euo pipefail
            
            # Check available docker compose commands
            echo "üîç Checking docker compose availability:"
            if command -v docker &> /dev/null; then
              echo "‚úÖ docker available"
              docker --version
            fi
            if docker compose version &> /dev/null; then
              echo "‚úÖ docker compose available"
              docker compose version
              dco() { docker compose "$@"; }
            elif command -v docker-compose &> /dev/null; then
              echo "‚úÖ docker-compose available"  
              docker-compose --version
              dco() { docker-compose "$@"; }
            else
              echo "‚ùå Neither docker compose nor docker-compose found!"
              exit 1
            fi

            echo "üîç Debug environment variables:"
            echo "APP_NAME: $APP_NAME"
            echo "AR_REPO_NAME: $AR_REPO_NAME"
            echo "AR_REGION: $AR_REGION"  
            echo "GCP_PROJECT_ID: $GCP_PROJECT_ID"
            echo "GITHUB_SHA: $GITHUB_SHA"
            
            # Construct AR_HOST and IMAGE_URI directly (bypass GitHub's secret filtering)
            AR_HOST="${AR_REGION}-docker.pkg.dev"
            IMAGE_URI="${AR_HOST}/${GCP_PROJECT_ID}/${AR_REPO_NAME}/${APP_NAME}:${GITHUB_SHA}"
            
            echo "üîç Constructed values:"
            echo "AR_HOST: $AR_HOST"
            echo "IMAGE_URI: $IMAGE_URI"
            
            # Validate construction
            if [[ -z "$AR_HOST" ]] || [[ -z "$IMAGE_URI" ]]; then
              echo "‚ùå ERROR: Failed to construct AR_HOST or IMAGE_URI!"
              echo "Check that all required environment variables are set."
              exit 1
            fi
            
            echo "‚úÖ Successfully constructed deployment values"

            APP_DIR="/opt/$APP_NAME"
            sudo mkdir -p "$APP_DIR"
            sudo chown "$USER:$USER" "$APP_DIR"
            cd "$APP_DIR"

            echo "üîê Docker login to ${AR_HOST} using CI token"
            echo "${AR_TOKEN}" | docker login -u oauth2accesstoken --password-stdin "${AR_HOST}"
            
            echo "‚úÖ AR Connection Details:"
            echo "AR Host: ${AR_HOST}"
            echo "AR Repository: ${AR_REPO_NAME}"
            echo "AR Region: ${AR_REGION}"
            echo "Image to deploy: ${IMAGE_URI}"

            echo "üîß Fix .env file location and add missing vars FIRST"
            if [ -f ".env" ] && [ ! -f "secure-docker-setup/.env" ]; then
              echo "Copying .env to secure-docker-setup/"
              cp .env secure-docker-setup/.env
              
              # Add REDIS_PASSWORD if not present
              if ! grep -q "REDIS_PASSWORD" secure-docker-setup/.env; then
                echo "REDIS_PASSWORD=secure_redis_pass_$(openssl rand -hex 12)" >> secure-docker-setup/.env
                echo "Added REDIS_PASSWORD to .env"
              fi
            fi

            echo "üìù Fix compose file and patch image"
            # Remove obsolete version field
            sed -i "/^version:/d" secure-docker-setup/docker-compose.secure.yml || true

            echo "üï∏Ô∏è Ensure networks"
            docker network create web 2>/dev/null || true
            docker network create bot_internal --internal 2>/dev/null || true

            echo "üßπ Stop previous services (idempotent)"
            dco -f secure-docker-setup/docker-compose.secure.yml down --remove-orphans || true
            if [ -d "infra/caddy" ]; then
              ( cd infra/caddy && dco down || true )
            fi
            
            # Update image
            echo "üìù Patch compose to use ${IMAGE_URI}"
            sed -i "s|^\s*build:.*|image: ${IMAGE_URI}|g" secure-docker-setup/docker-compose.secure.yml || true
            sed -i "s|^\s*context:.*||g" secure-docker-setup/docker-compose.secure.yml || true
            sed -i "s|^\s*dockerfile:.*||g" secure-docker-setup/docker-compose.secure.yml || true

            echo "üîê Set perms"
            chmod 600 .env 2>/dev/null || true

            echo "üåê Start/Reload Caddy (if present)"
            if [ -d "infra/caddy" ]; then
              cd infra/caddy
              dco up -d
              sleep 4
              dco ps || true
              cd "$APP_DIR"
            fi

            echo "ü§ñ Deploy app"
            dco -f secure-docker-setup/docker-compose.secure.yml pull
            dco -f secure-docker-setup/docker-compose.secure.yml up -d

            echo "üîé Containers:"
            docker ps --format 'table {{.Names}}\t{{.Status}}\t{{.Ports}}'

  health:
    name: üè• Health & Logs
    runs-on: ubuntu-latest
    needs: [deploy]
    steps:
      - name: üîê Auth GCP (for curl timeout on runner only)
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: üåê External health check
        run: |
          set -x
          if timeout 12 curl -fsS "http://${{ env.VM_HOST }}/health" >/dev/null; then
            echo "‚úÖ External /health OK"
          else
            echo "‚ùå External /health failed"
          fi

      - name: üîé VM container status & logs
        uses: appleboy/ssh-action@v1.0.3
        with:
          host:     ${{ env.VM_HOST }}
          username: ${{ env.VM_SSH_USER }}
          key:      ${{ secrets.VM_SSH_KEY }}
          script: |
            set -euo pipefail
            echo "üîç docker ps"
            docker ps --format 'table {{.Names}}\t{{.Status}}\t{{.Ports}}' || true

            echo
            echo "üìã Recent app logs (tail 200)"
            docker logs ${APP_NAME} --tail 200 || true

            echo
            echo "üìã Recent caddy logs (tail 120)"
            docker logs caddy  --tail 120 || true
            docker logs caddy-proxy --tail 120 || true
